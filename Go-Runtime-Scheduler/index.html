<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Go runtime 调度器 - Kira's Blog</title>

  <!-- Edit site and author settings in `_config.yml` to make the social details your own -->

    <meta content="Kira's Blog" property="og:site_name">
  
    <meta content="Go runtime 调度器" property="og:title">
  
  
    <meta content="article" property="og:type">
  
  
    <meta content="Go runtime 调度器源码分析" property="og:description">
  
  
    <meta content="https://imkira.com/Go-Runtime-Scheduler/" property="og:url">
  
  
    <meta content="2016-10-08T01:45:13+00:00" property="article:published_time">
    <meta content="https://imkira.com/about/" property="article:author">
  
  
    <meta content="https://imkira.com/assets/img/avatar.jpg" property="og:image">
  
  
    
  
  
    
    <meta content="Golang" property="article:tag">
    
  

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@">
    <meta name="twitter:creator" content="@">
  
    <meta name="twitter:title" content="Go runtime 调度器">
  
  
    <meta name="twitter:url" content="https://imkira.com/Go-Runtime-Scheduler/">
  
  
    <meta name="twitter:description" content="Go runtime 调度器源码分析">
  
  
    <meta name="twitter:image:src" content="https://imkira.com/assets/img/avatar.jpg">
  

	<meta name="description" content="Go runtime 调度器源码分析">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta property="og:image" content="">
	<link rel="shortcut icon" href="/assets/img/favicon/favicon.ico" type="image/x-icon">
	<link rel="apple-touch-icon" href="/assets/img/favicon/apple-touch-icon.png">
	<link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicon/apple-touch-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicon/apple-touch-icon-144x144.png">
	<!-- Chrome, Firefox OS and Opera -->
	<meta name="theme-color" content="#263959">
	<!-- Windows Phone -->
	<meta name="msapplication-navbutton-color" content="#263959">
	<!-- iOS Safari -->
	<meta name="apple-mobile-web-app-status-bar-style" content="#263959">
	<!-- Google Fonts -->
	<link href="https://fonts.googleapis.com/css?family=PT+Serif:400,700" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700" rel="stylesheet">
	<!-- Font Awesome -->
	<link rel="stylesheet" href="/assets/fonts/font-awesome/css/font-awesome.min.css">
	<!-- Styles -->
	<link rel="stylesheet" href="/assets/css/main.css">
</head>

<body>

  <div class="wrapper">
    <aside class="sidebar">
  <header>
    <div class="about">
      <div class="cover-author-image">
        <a href="/"><img src="/assets/img/avatar.jpg" alt="Wei Guo"></a>
      </div>
      <div class="author-name">Wei Guo</div>
      <p>Author of Nirvana API Framewark. Focus on CloudNative technologies.</p>
    </div>
  </header> <!-- End Header -->
  <footer>
    <section class="contact">
      <h3 class="contact-title">Contact me</h3>
      <ul>
        
          <li><a href="https://twitter.com/artemsheludko_" target="_blank"><i class="fa fa-twitter" aria-hidden="true"></i></a></li>
        
        
          <li><a href="https://facebook.com/" target="_blank"><i class="fa fa-facebook" aria-hidden="true"></i></a></li>
        
        
          <li class="github"><a href="http://github.com/kdada" target="_blank"><i class="fa fa-github"></i></a></li>
        
        
          <li class="linkedin"><a href="https://in.linkedin.com/" target="_blank"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li>
        
        
          <li class="email"><a href="mailto:me@imkira.com"><i class="fa fa-envelope-o"></i></a></li>
        
      </ul>
    </section> <!-- End Section Contact -->
    <div class="copyright">
      <p>2025 &copy; Wei Guo</p>
    </div>
  </footer> <!-- End Footer -->
</aside> <!-- End Sidebar -->
<div class="content-box clearfix">
  <article class="article-page">
  <div class="page-content">
    
    
    <div class="wrap-content">
      <header class="header-page">
        <h1 class="page-title">Go runtime 调度器</h1>
        <div class="page-date"><span>2016, Oct 08&nbsp;&nbsp;&nbsp;&nbsp;</span></div>
      </header>
      <h4 id="分析环境">分析环境:</h4>
<p>go:1.7 linux amd64<br />
分析中使用的汇编相关的内容也是 64 位的, 例如栈顶寄存器 rsp 等 (32 位的是 esp,16 位的是 sp)</p>

<h4 id="1go-调度器结构">1.Go 调度器结构</h4>

<h5 id="gruntimegruntimeruntime2go306该结构体用于描述一个-goroutine">G:runtime.g(runtime/runtime2.go#306)，该结构体用于描述一个 goroutine</h5>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 栈</span>
<span class="k">type</span> <span class="n">stack</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="c">// 栈下界指针</span>
    <span class="n">lo</span> <span class="kt">uintptr</span>
    <span class="c">// 栈上界指针</span>
    <span class="n">hi</span> <span class="kt">uintptr</span>
<span class="p">}</span>
<span class="c">// 代表一个 goroutine</span>
<span class="k">type</span> <span class="n">g</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="c">// 描述当前 g 的栈信息</span>
    <span class="n">stack</span>       <span class="n">stack</span>
    <span class="c">// 栈界限 (守卫), 用于一般 goroutine</span>
    <span class="n">stackguard0</span> <span class="kt">uintptr</span>
    <span class="c">// 栈界限 (守卫), 用于 g0 和 gsignal</span>
    <span class="n">stackguard1</span> <span class="kt">uintptr</span>
    <span class="c">// 如果 G 正在运行, m 指向运行当前 goroutine 的 M</span>
    <span class="n">m</span>           <span class="o">*</span><span class="n">m</span>
    <span class="c">//goroutine 现场信息, 在 goroutine 切换的时候需要保存和恢复该信息</span>
    <span class="n">sched</span>       <span class="n">gobuf</span>
    <span class="c">// 当前 G 的状态 (参考 runtime/runtime2.go#14)</span>
    <span class="n">atomicstatus</span>   <span class="kt">uint32</span>
    <span class="c">// 标记是否要抢占式调度</span>
    <span class="n">preempt</span>        <span class="kt">bool</span>
    <span class="c">// 锁定 M, 即表示当前的 G 具有线程亲和性, 需要在制定的线程中执行</span>
    <span class="n">lockedm</span>     <span class="o">*</span><span class="n">m</span>
    <span class="c">// 其他字段</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div></div>
<p>栈的范围是 [lo, hi)，栈是从上往下使用的, 即开始时 rsp 为 hi，当 push 一个 64 位指针后, rsp=hi-8, 此时栈已使用部分为 [rsp,hi)。</p>

<p>每个 goroutine 创建时都会创建一个对应的 g 结构体，g 结构体中包含了该 goroutine 的所有信息。</p>

<p>go 在编译函数的时候, 会在每个函数的开头插入一段代码，代码判断 rsp &lt; staic.lo+StackGuard，如果为 true 则表示剩余的栈空间不够用了, 需要对栈进行扩容。
扩容后栈变为当前栈的 2 倍，并且将当前栈的所有数据复制到新的栈中，并改变 g 的 stack 相关信息。</p>

<h5 id="mruntimemruntimeruntime2go377该结构体用于描述一个操作系统线程">M:runtime.m(runtime/runtime2.go#377)，该结构体用于描述一个操作系统线程</h5>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">m</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="c">// 拥有调度栈的 goroutine</span>
    <span class="n">g0</span>      <span class="o">*</span><span class="n">g</span>
    <span class="c">// 处理信号的 goroutine</span>
    <span class="n">gsignal</span> <span class="o">*</span><span class="n">g</span>
    <span class="c">// 附加在当前 M 上的 P, 如果当前 M 处于空闲状态, p 为 nil</span>
    <span class="n">p</span>        <span class="n">puintptr</span>
    <span class="c">// 操作系统线程 handle</span>
    <span class="n">thread</span>   <span class="kt">uintptr</span>
    <span class="c">// 为 true 说明当前线程正处于没事找事的状态</span>
    <span class="n">spinning</span> <span class="kt">bool</span>
    <span class="c">// 其他字段</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div></div>
<p>M 与操作系统线程一一对应，M 与 P 关联，并且在 P 给出 G 后，执行 G。</p>

<h5 id="pruntimepruntimeruntime2go444该结构体描述一个-go-processor-结构">P:runtime.p(runtime/runtime2.go#444)，该结构体描述一个 go processor 结构</h5>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">p</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="c">// 处理器状态 (参考 runtime/runtime2.go#91)</span>
    <span class="n">status</span>      <span class="kt">uint32</span>
    <span class="c">// 关联的线程 M 信息, 如果 P 处于空闲状态, m 为 nil</span>
    <span class="n">m</span>           <span class="n">muintptr</span>
    <span class="c">// 当前 P 所持有的 G 队列, P 处于运行状态时从该队列中 pop 出一个 G 来执行</span>
    <span class="n">runqhead</span> <span class="kt">uint32</span>
    <span class="n">runqtail</span> <span class="kt">uint32</span>
    <span class="n">runq</span>     <span class="p">[</span><span class="m">256</span><span class="p">]</span><span class="n">guintptr</span>
    <span class="c">// 处于死亡状态的 G, 作为对象池来使用</span>
    <span class="c">// 当前 P 上的 G 新建 goroutine 的时候会先从这里取出已经死亡的 G 来使用, 避免频繁创建 G 结构体</span>
    <span class="n">gfree</span>    <span class="o">*</span><span class="n">g</span>
    <span class="n">gfreecnt</span> <span class="kt">int32</span>
    <span class="c">// 其他字段</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>P 负责管理 G 的运行队列，通常情况下，P 的数量和 CPU 核心的数量一致（可以通过 GOMAXPROCS 修改 P 的数量）。<br />
P 的基本流程：</p>
<ol>
  <li>一个运行状态的 P（已经绑定了一个 M）首先从全局运行队列里获取 G 来运行</li>
  <li>如果全局运行队列内没有可以运行的 G，那么去其他 P 那里获取一半的运行队列（分摊工作），并开始运行</li>
  <li>如果 1 和 2 都没有找到可以运行的 G，那么进入空闲状态，同时对应的 M 也进入空闲的状态</li>
  <li>如果当前运行的 G 进入 SYSCALL 状态，那么 G 所属的 P 会 * 单方面解除 * 对 M 的引用（entersyscall 时执行），此时 P 处于 Psyscall 状态</li>
  <li>解除绑定后的 P 接受 sysmon 管理，并且由 sysmon 重新分配一个可以运行的 M，此后 P 会继续执行其他的 G（runtime/proc.go#3687 retake）</li>
  <li>如果在此期间 sysmon 找不到空闲的 M，那么 sysmon 会将 P 设置为空闲状态，并将 P 剩余的 G 放到全局运行队列中（runtime/proc.go#1663 handoffp）</li>
  <li>由于 sysmon 是周期性执行，因此如果在 sysmon 处理 P 之前 SYSCALL 就已经返回了，那么 M 能够通过对 P 的引用找回 P 并重新开始执行 (exitsyscall 时执行)</li>
</ol>

<h4 id="2sysmon-系统监控">2.sysmon 系统监控</h4>
<p>sysmon 是监控线程，用于监控系统的运行状况，包括 G，P，M 的执行情况，网络的状态检查等。（runtime/proc.go#3580 sysmon）</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// sysmon 运行过程中不需要 P，总是独占一个线程</span>
<span class="k">func</span> <span class="n">sysmon</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// 记录下面的 for 循环连续没事做的次数</span>
	<span class="n">idle</span> <span class="o">:=</span> <span class="m">0</span>
    <span class="c">// 延迟时间, 即下次运行前 sleep 的时间</span>
	<span class="n">delay</span> <span class="o">:=</span> <span class="kt">uint32</span><span class="p">(</span><span class="m">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">idle</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
            <span class="c">// 如果上次循环的时候就有事做，那么下次做事前先休息 20 微秒</span>
			<span class="n">delay</span> <span class="o">=</span> <span class="m">20</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">idle</span> <span class="o">&gt;</span> <span class="m">50</span> <span class="p">{</span>
            <span class="c">// 如果前面 50 次循环都没有事情做，那么睡眠时间开始增长</span>
			<span class="n">delay</span> <span class="o">*=</span> <span class="m">2</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="n">delay</span> <span class="o">&gt;</span> <span class="m">10</span><span class="o">*</span><span class="m">1000</span> <span class="p">{</span>
            <span class="c">// 睡眠时间不能超过 10ms</span>
			<span class="n">delay</span> <span class="o">=</span> <span class="m">10</span> <span class="o">*</span> <span class="m">1000</span>
		<span class="p">}</span>
        <span class="c">// 调用操作系统的 sleep 函数让 M(操作系统线程) 休眠, 与 time.Sleep 不同, time.Sleep 只会让 G 休眠而不会让 M 休眠</span>
		<span class="n">usleep</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>
        <span class="c">// 忽略部分代码</span>
        <span class="o">...</span>
        <span class="c">// 检查网络状态, 即对于那些因网络调用而阻塞的 G, 在此处检查相应状态, 如果状态符合要求就将对应的 G 从 Gwaiting 转换为 Grunnable</span>
		<span class="c">// poll network if not polled for more than 10ms</span>
		<span class="n">lastpoll</span> <span class="o">:=</span> <span class="kt">int64</span><span class="p">(</span><span class="n">atomic</span><span class="o">.</span><span class="n">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched</span><span class="o">.</span><span class="n">lastpoll</span><span class="p">))</span>
		<span class="n">now</span> <span class="o">:=</span> <span class="n">nanotime</span><span class="p">()</span>
		<span class="n">unixnow</span> <span class="o">:=</span> <span class="n">unixnanotime</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">lastpoll</span> <span class="o">!=</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="n">lastpoll</span><span class="o">+</span><span class="m">10</span><span class="o">*</span><span class="m">1000</span><span class="o">*</span><span class="m">1000</span> <span class="o">&lt;</span> <span class="n">now</span> <span class="p">{</span>
			<span class="n">atomic</span><span class="o">.</span><span class="n">Cas64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched</span><span class="o">.</span><span class="n">lastpoll</span><span class="p">,</span> <span class="kt">uint64</span><span class="p">(</span><span class="n">lastpoll</span><span class="p">),</span> <span class="kt">uint64</span><span class="p">(</span><span class="n">now</span><span class="p">))</span>
			<span class="n">gp</span> <span class="o">:=</span> <span class="n">netpoll</span><span class="p">(</span><span class="no">false</span><span class="p">)</span> <span class="c">// non-blocking - returns list of goroutines</span>
			<span class="k">if</span> <span class="n">gp</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
				<span class="c">// Need to decrement number of idle locked M's</span>
				<span class="c">// (pretending that one more is running) before injectglist.</span>
				<span class="c">// Otherwise it can lead to the following situation:</span>
				<span class="c">// injectglist grabs all P's but before it starts M's to run the P's,</span>
				<span class="c">// another M returns from syscall, finishes running its G,</span>
				<span class="c">// observes that there is no work to do and no other running M's</span>
				<span class="c">// and reports deadlock.</span>
				<span class="n">incidlelocked</span><span class="p">(</span><span class="o">-</span><span class="m">1</span><span class="p">)</span>
				<span class="n">injectglist</span><span class="p">(</span><span class="n">gp</span><span class="p">)</span>
				<span class="n">incidlelocked</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
        <span class="c">// 在此处检查处于 SYSCALL 的 P 并进行处理</span>
		<span class="c">//retake 还检查了执行过长的 G</span>
		<span class="k">if</span> <span class="n">retake</span><span class="p">(</span><span class="n">now</span><span class="p">)</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
			<span class="n">idle</span> <span class="o">=</span> <span class="m">0</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">idle</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="c">// 检查是否需要 GC</span>
		<span class="n">lastgc</span> <span class="o">:=</span> <span class="kt">int64</span><span class="p">(</span><span class="n">atomic</span><span class="o">.</span><span class="n">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memstats</span><span class="o">.</span><span class="n">last_gc</span><span class="p">))</span>
		<span class="k">if</span> <span class="n">gcphase</span> <span class="o">==</span> <span class="n">_GCoff</span> <span class="o">&amp;&amp;</span> <span class="n">lastgc</span> <span class="o">!=</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="n">unixnow</span><span class="o">-</span><span class="n">lastgc</span> <span class="o">&gt;</span> <span class="n">forcegcperiod</span> <span class="o">&amp;&amp;</span> <span class="n">atomic</span><span class="o">.</span><span class="n">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">forcegc</span><span class="o">.</span><span class="n">idle</span><span class="p">)</span> <span class="o">!=</span> <span class="m">0</span> <span class="p">{</span>
			<span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">forcegc</span><span class="o">.</span><span class="n">lock</span><span class="p">)</span>
			<span class="n">forcegc</span><span class="o">.</span><span class="n">idle</span> <span class="o">=</span> <span class="m">0</span>
			<span class="n">forcegc</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">schedlink</span> <span class="o">=</span> <span class="m">0</span>
			<span class="n">injectglist</span><span class="p">(</span><span class="n">forcegc</span><span class="o">.</span><span class="n">g</span><span class="p">)</span>
			<span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">forcegc</span><span class="o">.</span><span class="n">lock</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c">// scavenge heap once in a while</span>
		<span class="k">if</span> <span class="n">lastscavenge</span><span class="o">+</span><span class="n">scavengelimit</span><span class="o">/</span><span class="m">2</span> <span class="o">&lt;</span> <span class="n">now</span> <span class="p">{</span>
			<span class="n">mheap_</span><span class="o">.</span><span class="n">scavenge</span><span class="p">(</span><span class="kt">int32</span><span class="p">(</span><span class="n">nscavenge</span><span class="p">),</span> <span class="kt">uint64</span><span class="p">(</span><span class="n">now</span><span class="p">),</span> <span class="kt">uint64</span><span class="p">(</span><span class="n">scavengelimit</span><span class="p">))</span>
			<span class="n">lastscavenge</span> <span class="o">=</span> <span class="n">now</span>
			<span class="n">nscavenge</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="n">debug</span><span class="o">.</span><span class="n">schedtrace</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="n">lasttrace</span><span class="o">+</span><span class="kt">int64</span><span class="p">(</span><span class="n">debug</span><span class="o">.</span><span class="n">schedtrace</span><span class="p">)</span><span class="o">*</span><span class="m">1000000</span> <span class="o">&lt;=</span> <span class="n">now</span> <span class="p">{</span>
			<span class="n">lasttrace</span> <span class="o">=</span> <span class="n">now</span>
			<span class="n">schedtrace</span><span class="p">(</span><span class="n">debug</span><span class="o">.</span><span class="n">scheddetail</span> <span class="o">&gt;</span> <span class="m">0</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>处于 SYSCALL 状态的 P 的执行依赖于 retake 方法（runtime/proc.go#3687 retake）：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">retake</span><span class="p">(</span><span class="n">now</span> <span class="kt">int64</span><span class="p">)</span> <span class="kt">uint32</span> <span class="p">{</span>
	<span class="n">n</span> <span class="o">:=</span> <span class="m">0</span>
    <span class="c">// 遍历所有的 P</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="kt">int32</span><span class="p">(</span><span class="m">0</span><span class="p">);</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">gomaxprocs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">_p_</span> <span class="o">:=</span> <span class="n">allp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">_p_</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="n">pd</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">pdesc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
		<span class="n">s</span> <span class="o">:=</span> <span class="n">_p_</span><span class="o">.</span><span class="n">status</span>
		<span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">_Psyscall</span> <span class="p">{</span>
            <span class="c">// 超过一次 sysmon 循环所需要的时间的 P, 才会被 retake 处理, 具体时间由 sysmon 的 delay 决定, 最少 20 微秒</span>
			<span class="c">// Retake P from syscall if it's there for more than 1 sysmon tick (at least 20us).</span>
			<span class="n">t</span> <span class="o">:=</span> <span class="kt">int64</span><span class="p">(</span><span class="n">_p_</span><span class="o">.</span><span class="n">syscalltick</span><span class="p">)</span>
			<span class="k">if</span> <span class="kt">int64</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">syscalltick</span><span class="p">)</span> <span class="o">!=</span> <span class="n">t</span> <span class="p">{</span>
				<span class="n">pd</span><span class="o">.</span><span class="n">syscalltick</span> <span class="o">=</span> <span class="kt">uint32</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
				<span class="n">pd</span><span class="o">.</span><span class="n">syscallwhen</span> <span class="o">=</span> <span class="n">now</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="c">// On the one hand we don't want to retake Ps if there is no other work to do,</span>
			<span class="c">// but on the other hand we want to retake them eventually</span>
			<span class="c">// because they can prevent the sysmon thread from deep sleep.</span>
			<span class="k">if</span> <span class="n">runqempty</span><span class="p">(</span><span class="n">_p_</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">atomic</span><span class="o">.</span><span class="n">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched</span><span class="o">.</span><span class="n">nmspinning</span><span class="p">)</span><span class="o">+</span><span class="n">atomic</span><span class="o">.</span><span class="n">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched</span><span class="o">.</span><span class="n">npidle</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="n">pd</span><span class="o">.</span><span class="n">syscallwhen</span><span class="o">+</span><span class="m">10</span><span class="o">*</span><span class="m">1000</span><span class="o">*</span><span class="m">1000</span> <span class="o">&gt;</span> <span class="n">now</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="c">// Need to decrement number of idle locked M's</span>
			<span class="c">// (pretending that one more is running) before the CAS.</span>
			<span class="c">// Otherwise the M from which we retake can exit the syscall,</span>
			<span class="c">// increment nmidle and report deadlock.</span>
			<span class="n">incidlelocked</span><span class="p">(</span><span class="o">-</span><span class="m">1</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">atomic</span><span class="o">.</span><span class="n">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_p_</span><span class="o">.</span><span class="n">status</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">_Pidle</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="n">trace</span><span class="o">.</span><span class="n">enabled</span> <span class="p">{</span>
					<span class="n">traceGoSysBlock</span><span class="p">(</span><span class="n">_p_</span><span class="p">)</span>
					<span class="n">traceProcStop</span><span class="p">(</span><span class="n">_p_</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="n">n</span><span class="o">++</span>
				<span class="n">_p_</span><span class="o">.</span><span class="n">syscalltick</span><span class="o">++</span>
				<span class="n">handoffp</span><span class="p">(</span><span class="n">_p_</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="n">incidlelocked</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">_Prunning</span> <span class="p">{</span>
            <span class="c">// 如果 P 处于运行状态, 并且 G 运行时间太久了, 那么就对 G 进行抢占</span>
			<span class="c">// Preempt G if it's running for too long.</span>
			<span class="n">t</span> <span class="o">:=</span> <span class="kt">int64</span><span class="p">(</span><span class="n">_p_</span><span class="o">.</span><span class="n">schedtick</span><span class="p">)</span>
			<span class="k">if</span> <span class="kt">int64</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">schedtick</span><span class="p">)</span> <span class="o">!=</span> <span class="n">t</span> <span class="p">{</span>
				<span class="n">pd</span><span class="o">.</span><span class="n">schedtick</span> <span class="o">=</span> <span class="kt">uint32</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
				<span class="n">pd</span><span class="o">.</span><span class="n">schedwhen</span> <span class="o">=</span> <span class="n">now</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">schedwhen</span><span class="o">+</span><span class="n">forcePreemptNS</span> <span class="o">&gt;</span> <span class="n">now</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="n">preemptone</span><span class="p">(</span><span class="n">_p_</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kt">uint32</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>在 retake 中发生的抢占式调度的说明：</p>
<ol>
  <li>通过记录一个 G 的执行时间来判断 G 是否执行太久</li>
  <li>通过设置 G 的 preempt（设置为 true）和 stackguard0（设置为 stackPreempt runtime/static.go#135）来标记该 G 需要被抢占式调度</li>
  <li>这个抢占式调度是被动的，只有当 G 发生函数调用时，在函数头进行栈检查的时候，才会去检查是否要让出执行权。</li>
</ol>

<p>如果发生以下两种情况，那么抢占式调度无效：</p>
<ol>
  <li>G 执行过程中，不调用其他函数</li>
  <li>G 调用其他函数，但是这些函数头部没有栈检查（当 go 的编译器认为该函数所需栈太小时, 就不会给在该函数头部添加栈检查）</li>
</ol>

      <div class="page-footer">
        <div class="page-share">
          <a href="https://twitter.com/intent/tweet?text=Go runtime 调度器&url=https://imkira.com/Go-Runtime-Scheduler/" title="Share on Twitter" rel="nofollow" target="_blank">Twitter</a>
          <a href="https://facebook.com/sharer.php?u=https://imkira.com/Go-Runtime-Scheduler/" title="Share on Facebook" rel="nofollow" target="_blank">Facebook</a>
          <a href="https://plus.google.com/share?url=https://imkira.com/Go-Runtime-Scheduler/" title="Share on Google+" rel="nofollow" target="_blank">Google+</a>
        </div>
        <div class="page-tag">
          
            <a href="/tags#Golang" class="tag">&#35; Golang</a>
          
        </div>
      </div>
      <section class="comment-area">
  <div class="comment-wrapper">
    
  </div>
</section> <!-- End Comment Area -->

    </div> <!-- End Wrap Content -->
  </div> <!-- End Page Content -->
</article> <!-- End Article Page -->

</div>

  </div>
  
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', '', 'auto');
  ga('send', 'pageview');
</script> <!-- End Analytics -->

</body>
</html>
