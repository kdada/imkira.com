<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Centos 7 systemd 死锁问题分析 - Kira's Blog</title>

  <!-- Edit site and author settings in `_config.yml` to make the social details your own -->

    <meta content="Kira's Blog" property="og:site_name">
  
    <meta content="Centos 7 systemd 死锁问题分析" property="og:title">
  
  
    <meta content="article" property="og:type">
  
  
    <meta content="Centos 7 systemd 死锁问题分析" property="og:description">
  
  
    <meta content="https://imkira.com/Linux-Systemd-Deadlock/" property="og:url">
  
  
    <meta content="2018-07-19T01:07:55+00:00" property="article:published_time">
    <meta content="https://imkira.com/about/" property="article:author">
  
  
    <meta content="https://imkira.com/assets/img/avatar.jpg" property="og:image">
  
  
    
  
  
    
    <meta content="Linux" property="article:tag">
    
  

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@">
    <meta name="twitter:creator" content="@">
  
    <meta name="twitter:title" content="Centos 7 systemd 死锁问题分析">
  
  
    <meta name="twitter:url" content="https://imkira.com/Linux-Systemd-Deadlock/">
  
  
    <meta name="twitter:description" content="Centos 7 systemd 死锁问题分析">
  
  
    <meta name="twitter:image:src" content="https://imkira.com/assets/img/avatar.jpg">
  

	<meta name="description" content="Centos 7 systemd 死锁问题分析">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta property="og:image" content="">
	<link rel="shortcut icon" href="/assets/img/favicon/favicon.ico" type="image/x-icon">
	<link rel="apple-touch-icon" href="/assets/img/favicon/apple-touch-icon.png">
	<link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicon/apple-touch-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicon/apple-touch-icon-144x144.png">
	<!-- Chrome, Firefox OS and Opera -->
	<meta name="theme-color" content="#263959">
	<!-- Windows Phone -->
	<meta name="msapplication-navbutton-color" content="#263959">
	<!-- iOS Safari -->
	<meta name="apple-mobile-web-app-status-bar-style" content="#263959">
	<!-- Google Fonts -->
	<link href="https://fonts.googleapis.com/css?family=PT+Serif:400,700" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700" rel="stylesheet">
	<!-- Font Awesome -->
	<link rel="stylesheet" href="/assets/fonts/font-awesome/css/font-awesome.min.css">
	<!-- Styles -->
	<link rel="stylesheet" href="/assets/css/main.css">
</head>

<body>

  <div class="wrapper">
    <aside class="sidebar">
  <header>
    <div class="about">
      <div class="cover-author-image">
        <a href="/"><img src="/assets/img/avatar.jpg" alt="Wei Guo"></a>
      </div>
      <div class="author-name">Wei Guo</div>
      <p>Author of Nirvana API Framewark. Focus on CloudNative technologies.</p>
    </div>
  </header> <!-- End Header -->
  <footer>
    <section class="contact">
      <h3 class="contact-title">Contact me</h3>
      <ul>
        
          <li><a href="https://twitter.com/artemsheludko_" target="_blank"><i class="fa fa-twitter" aria-hidden="true"></i></a></li>
        
        
          <li><a href="https://facebook.com/" target="_blank"><i class="fa fa-facebook" aria-hidden="true"></i></a></li>
        
        
          <li class="github"><a href="http://github.com/kdada" target="_blank"><i class="fa fa-github"></i></a></li>
        
        
          <li class="linkedin"><a href="https://in.linkedin.com/" target="_blank"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li>
        
        
          <li class="email"><a href="mailto:me@imkira.com"><i class="fa fa-envelope-o"></i></a></li>
        
      </ul>
    </section> <!-- End Section Contact -->
    <div class="copyright">
      <p>2025 &copy; Wei Guo</p>
    </div>
  </footer> <!-- End Footer -->
</aside> <!-- End Sidebar -->
<div class="content-box clearfix">
  <article class="article-page">
  <div class="page-content">
    
    
    <div class="wrap-content">
      <header class="header-page">
        <h1 class="page-title">Centos 7 systemd 死锁问题分析</h1>
        <div class="page-date"><span>2018, Jul 19&nbsp;&nbsp;&nbsp;&nbsp;</span></div>
      </header>
      <h3 id="问题分析">问题分析</h3>

<p>系统信息：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      KERNEL: /lib/debug/lib/modules/3.10.0-693.el7.x86_64/vmlinux
    DUMPFILE: ./systemd-hang-c221v38/vmcore  [PARTIAL DUMP]
        CPUS: 4
        DATE: Mon Jun 11 14:23:55 2018
      UPTIME: 13 days, 20:36:45
LOAD AVERAGE: 2.10, 2.10, 2.07
       TASKS: 244
    NODENAME: c221v38
     RELEASE: 3.10.0-693.el7.x86_64
     VERSION: #1 SMP Tue Aug 22 21:09:27 UTC 2017
     MACHINE: x86_64  (2199 Mhz)
      MEMORY: 8 GB
       PANIC: "SysRq : Trigger a crash"
</code></pre></div></div>
<p>处于 UN 状态的 Tasks：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#    PID    PPID  CPU       TASK        ST  %MEM     VSZ    RSS  COMM
crash&gt; ps |grep UN
      1  1322389   3  ffff88017cd10000  UN   0.1  193608   6592  systemd
  1317113      2   3  ffff880029cd3f40  UN   0.0       0      0  [kworker/u8:1]
</code></pre></div></div>
<p>systemd 内核调用栈如下：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>crash&gt; bt -l ffff88017cd10000
PID: 1      TASK: ffff88017cd10000  CPU: 3   COMMAND: "systemd"
 #0 [ffff88017cd1bd10] __schedule at ffffffff816a8f45
    /usr/src/debug/kernel-3.10.0-693.el7/linux-3.10.0-693.el7.x86_64/kernel/sched/core.c: 2527
 #1 [ffff88017cd1bd78] schedule_preempt_disabled at ffffffff816aa3e9
    /usr/src/debug/kernel-3.10.0-693.el7/linux-3.10.0-693.el7.x86_64/kernel/sched/core.c: 3610
 #2 [ffff88017cd1bd88] __mutex_lock_slowpath at ffffffff816a8317
    /usr/src/debug/kernel-3.10.0-693.el7/linux-3.10.0-693.el7.x86_64/include/linux/spinlock.h: 301
 #3 [ffff88017cd1bde0] mutex_lock at ffffffff816a772f
    /usr/src/debug/kernel-3.10.0-693.el7/linux-3.10.0-693.el7.x86_64/arch/x86/include/asm/current.h: 14
 #4 [ffff88017cd1bdf8] mem_cgroup_write at ffffffff811f57e7
    /usr/src/debug/kernel-3.10.0-693.el7/linux-3.10.0-693.el7.x86_64/mm/memcontrol.c: 4638
 #5 [ffff88017cd1be68] cgroup_file_write at ffffffff8110aeef
    /usr/src/debug/kernel-3.10.0-693.el7/linux-3.10.0-693.el7.x86_64/kernel/cgroup.c: 2322
 #6 [ffff88017cd1bef8] vfs_write at ffffffff81200d2d
    /usr/src/debug/kernel-3.10.0-693.el7/linux-3.10.0-693.el7.x86_64/fs/read_write.c: 543
 #7 [ffff88017cd1bf38] sys_write at ffffffff81201b3f
    /usr/src/debug/kernel-3.10.0-693.el7/linux-3.10.0-693.el7.x86_64/fs/read_write.c: 566
 #8 [ffff88017cd1bf80] system_call_fastpath at ffffffff816b4fc9
    /usr/src/debug/kernel-3.10.0-693.el7/linux-3.10.0-693.el7.x86_64/arch/x86/kernel/entry_64.S: 444
    RIP: 00007f3ae83e385d  RSP: 00007ffff73b4350  RFLAGS: 00010246
    RAX: 0000000000000001  RBX: ffffffff816b4fc9  RCX: 0000000000001000
    RDX: 0000000000000003  RSI: 00007f3ae9bcf000  RDI: 0000000000000025
    RBP: 00007f3ae9bcf000   R8: 00007f3ae9bc1940   R9: 00007f3ae9bc1940
    R10: 0000000000000022  R11: 0000000000000293  R12: 0000000000000000
    R13: 0000000000000003  R14: 000055b2b54e10b0  R15: 0000000000000003
    ORIG_RAX: 0000000000000001  CS: 0033  SS: 002b
</code></pre></div></div>
<p>kworker/u8:1 内核调用栈如下：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>crash&gt; bt -l ffff880029cd3f40
PID: 1317113  TASK: ffff880029cd3f40  CPU: 3   COMMAND: "kworker/u8:1"
 #0 [ffff88018cf63ba0] __schedule at ffffffff816a8f45
    /usr/src/debug/kernel-3.10.0-693.el7/linux-3.10.0-693.el7.x86_64/kernel/sched/core.c: 2527
 #1 [ffff88018cf63c08] schedule_preempt_disabled at ffffffff816aa3e9
    /usr/src/debug/kernel-3.10.0-693.el7/linux-3.10.0-693.el7.x86_64/kernel/sched/core.c: 3610
 #2 [ffff88018cf63c18] __mutex_lock_slowpath at ffffffff816a8317
    /usr/src/debug/kernel-3.10.0-693.el7/linux-3.10.0-693.el7.x86_64/include/linux/spinlock.h: 301
 #3 [ffff88018cf63c70] mutex_lock at ffffffff816a772f
    /usr/src/debug/kernel-3.10.0-693.el7/linux-3.10.0-693.el7.x86_64/arch/x86/include/asm/current.h: 14
 #4 [ffff88018cf63c88] kmem_cache_destroy_memcg_children at ffffffff811f5fbe
    /usr/src/debug/kernel-3.10.0-693.el7/linux-3.10.0-693.el7.x86_64/mm/memcontrol.c: 3461
 #5 [ffff88018cf63cb0] kmem_cache_destroy at ffffffff811a6849
    /usr/src/debug/kernel-3.10.0-693.el7/linux-3.10.0-693.el7.x86_64/mm/slab_common.c: 282
 #6 [ffff88018cf63cd0] kmem_cache_destroy_memcg_children at ffffffff811f6009
    /usr/src/debug/kernel-3.10.0-693.el7/linux-3.10.0-693.el7.x86_64/mm/memcontrol.c: 3461
 #7 [ffff88018cf63cf8] kmem_cache_destroy at ffffffff811a6849
    /usr/src/debug/kernel-3.10.0-693.el7/linux-3.10.0-693.el7.x86_64/mm/slab_common.c: 282
 #8 [ffff88018cf63d18] nf_conntrack_cleanup_net_list at ffffffffc04075cb [nf_conntrack]
 #9 [ffff88018cf63d60] nf_conntrack_pernet_exit at ffffffffc040844d [nf_conntrack]
#10 [ffff88018cf63d88] ops_exit_list at ffffffff8157c473
    /usr/src/debug/kernel-3.10.0-693.el7/linux-3.10.0-693.el7.x86_64/net/core/net_namespace.c: 140
#11 [ffff88018cf63db8] cleanup_net at ffffffff8157d550
    /usr/src/debug/kernel-3.10.0-693.el7/linux-3.10.0-693.el7.x86_64/net/core/net_namespace.c: 451
#12 [ffff88018cf63e20] process_one_work at ffffffff810a881a
    /usr/src/debug/kernel-3.10.0-693.el7/linux-3.10.0-693.el7.x86_64/kernel/workqueue.c: 2252
#13 [ffff88018cf63e68] worker_thread at ffffffff810a94e6
    /usr/src/debug/kernel-3.10.0-693.el7/linux-3.10.0-693.el7.x86_64/include/linux/list.h: 188
#14 [ffff88018cf63ec8] kthread at ffffffff810b098f
    /usr/src/debug/kernel-3.10.0-693.el7/linux-3.10.0-693.el7.x86_64/kernel/kthread.c: 202
#15 [ffff88018cf63f50] ret_from_fork at ffffffff816b4f18
    /usr/src/debug/kernel-3.10.0-693.el7/linux-3.10.0-693.el7.x86_64/arch/x86/kernel/entry_64.S: 369
</code></pre></div></div>

<p>以上两个 task 的共同特点是在 mem_cgroup_write 和 kmem_cache_destroy_memcg_children 中都对 memcg_limit_mutex 进行的加锁操作，而且都卡在了这里。</p>

<p>查看 memcg_limit_mutex 的内存数据：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>crash&gt; p memcg_limit_mutex
memcg_limit_mutex = $7 = {
  count = {
    counter = -2
  },
  wait_lock = {
    {
      rlock = {
        raw_lock = {
          val = {
            counter = 0
          }
        }
      }
    }
  },
  wait_list = {
    next = 0xffff88018cf63c20,
    prev = 0xffff88017cd1bd90
  },
  owner = 0xffff880029cd3f40,
  {
    osq = {
      tail = {
        counter = 0
      }
    },
    __UNIQUE_ID_rh_kabi_hide1 = {
      spin_mlock = 0x0
    },
    {&lt;No data fields&gt;}
  }
}
</code></pre></div></div>
<p>通过内核源码可以知道 memcg_limit_mutex.count 的初始值为 1，现在上面的值为 -2，意味着有一个任务获取了锁，两个任务在等待队列中。并且 memcg_limit_mutex.owner 为 [kworker/u8:1]。</p>

<p>通过查看 memcg_limit_mutex.wait_list 得到等待任务链表：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>crash&gt; struct mutex_waiter 0xffff88018cf63c20
struct mutex_waiter {
  list = {
    next = 0xffff88017cd1bd90,
    prev = 0xffffffff81a77e28 &lt;memcg_limit_mutex+8&gt;
  },
  task = 0xffff880029cd3f40
}

crash&gt; struct mutex_waiter 0xffff88017cd1bd90
struct mutex_waiter {
  list = {
    next = 0xffffffff81a77e28 &lt;memcg_limit_mutex+8&gt;,
    prev = 0xffff88018cf63c20
  },
  task = 0xffff88017cd10000
}
</code></pre></div></div>
<p>从上面的结果可以看到， memcg_limit_mutex.wait_list 中有两个 task，第一个是 [kworker/u8:1]，第二个是 systemd。</p>

<p>所以第一个结论是，systemd 确实卡在了这个锁上，并且 [kworker/u8:1] 获取了锁之后，还没有释放，就又锁了一次，导致死锁。</p>

<p>分析了另外一份 vmcore 之后，现象和结论都和上面一致。</p>

<p>[kworker/u8:1] 反复调用了 kmem_cache_destroy 和 kmem_cache_destroy_memcg_children，导致了死锁。</p>

<h3 id="调试">调试</h3>

<p>下载 centos 7.4 内核源码 rpm 包： http://vault.centos.org/7.4.1708/os/x86_64/Packages/kernel-3.10.0-693.el7.x86_64.rpm。安装后在 ~/rpmbuild/SOURCES/linux-3.10.0-693.el7.tar.xz 取得内核源码。</p>

<p>在上面提到的相关函数中添加内核日志代码：</p>

<p>源码：mm/slab_common.c:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span>
<span class="nf">kmem_cache_create_memcg</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">align</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ctor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
			<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">parent_cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span>
			<span class="s">"kdbg: creating cache %s with cgroup %p and parent cache %p"</span><span class="p">,</span>
			<span class="n">name</span><span class="p">,</span> <span class="n">memcg</span><span class="p">,</span> <span class="n">parent_cache</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">get_online_cpus</span><span class="p">();</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slab_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kmem_cache_sanity_check</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_locked</span><span class="p">;</span>

	<span class="cm">/*
	 * Some allocators will constraint the set of valid flags to a subset
	 * of all flags. We expect them to define CACHE_CREATE_MASK in this
	 * case, and we'll just provide them with a sanitized version of the
	 * passed flags.
	 */</span>
	<span class="n">flags</span> <span class="o">&amp;=</span> <span class="n">CACHE_CREATE_MASK</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">__kmem_cache_alias</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">ctor</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">"kdbg: cache %s(%p) shares %s with refcount %d and %s"</span><span class="p">,</span>
				<span class="n">name</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="n">is_root_cache</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">?</span><span class="s">"root"</span><span class="o">:</span><span class="s">"nonroot"</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_locked</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">kmem_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">object_size</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">align</span> <span class="o">=</span> <span class="n">calculate_alignment</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">ctor</span> <span class="o">=</span> <span class="n">ctor</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">memcg_register_cache</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">parent_cache</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">kmem_cache</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_locked</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">kmem_cache</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_locked</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">__kmem_cache_create</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">refcount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slab_caches</span><span class="p">);</span>
			<span class="n">memcg_cache_list_add</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">"kdbg: allocated %s(%p) with refcount %d and %s"</span><span class="p">,</span>
					<span class="n">name</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="n">is_root_cache</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">?</span><span class="s">"root"</span><span class="o">:</span><span class="s">"nonroot"</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">kmem_cache</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

<span class="nl">out_locked:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slab_mutex</span><span class="p">);</span>
	<span class="n">put_online_cpus</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_PANIC</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">"kmem_cache_create: Failed to create slab'%s'. Error %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
				<span class="n">name</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">"kmem_cache_create(%s) failed with error %d"</span><span class="p">,</span>
				<span class="n">name</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
			<span class="n">dump_stack</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span>
<span class="nf">kmem_cache_create</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">align</span><span class="p">,</span>
		  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ctor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kmem_cache_create_memcg</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">ctor</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kmem_cache_create</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kmem_cache_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">"kdbg: recycle cache %p which is %s"</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span>
			<span class="n">is_root_cache</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">?</span><span class="s">"root"</span><span class="o">:</span><span class="s">"nonroot"</span><span class="p">);</span>

	<span class="cm">/* Destroy all the children caches if we aren't a memcg cache */</span>
	<span class="n">kmem_cache_destroy_memcg_children</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="n">get_online_cpus</span><span class="p">();</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slab_mutex</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__kmem_cache_shutdown</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slab_mutex</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_DESTROY_BY_RCU</span><span class="p">)</span>
				<span class="n">rcu_barrier</span><span class="p">();</span>

			<span class="n">memcg_release_cache</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">kmem_cache</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">"kdbg: recycled cache %p"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slab_caches</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slab_mutex</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">"kmem_cache_destroy %s: Slab cache still has objects</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">dump_stack</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slab_mutex</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">put_online_cpus</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>源码：mm/memcontrol.c</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">memcg_release_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>

	<span class="cm">/*
	 * This happens, for instance, when a root cache goes away before we
	 * add any memcg.
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">memcg_params</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">memcg_params</span><span class="o">-&gt;</span><span class="n">is_root_cache</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">memcg</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">memcg_params</span><span class="o">-&gt;</span><span class="n">memcg</span><span class="p">;</span>
	<span class="n">id</span>  <span class="o">=</span> <span class="n">memcg_cache_id</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>

	<span class="n">root</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">memcg_params</span><span class="o">-&gt;</span><span class="n">root_cache</span><span class="p">;</span>
	<span class="n">root</span><span class="o">-&gt;</span><span class="n">memcg_params</span><span class="o">-&gt;</span><span class="n">memcg_caches</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">"kdbg: remove cache %p from parent %p with index %d"</span><span class="p">,</span>
			<span class="n">s</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">slab_caches_mutex</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">memcg_params</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">slab_caches_mutex</span><span class="p">);</span>

	<span class="n">mem_cgroup_put</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">memcg_params</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kmem_cache_destroy_work_func</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">w</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">memcg_cache_params</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="k">struct</span> <span class="n">memcg_cache_params</span><span class="p">,</span> <span class="n">destroy</span><span class="p">);</span>

	<span class="n">cachep</span> <span class="o">=</span> <span class="n">memcg_params_to_cache</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">"kdbg: destroy worker for %p is called"</span><span class="p">,</span> <span class="n">cachep</span><span class="p">);</span>

	<span class="cm">/*
	 * If we get down to 0 after shrink, we could delete right away.
	 * However, memcg_release_pages() already puts us back in the workqueue
	 * in that case. If we proceed deleting, we'll get a dangling
	 * reference, and removing the object from the workqueue in that case
	 * is unnecessary complication. We are not a fast path.
	 *
	 * Note that this case is fundamentally different from racing with
	 * shrink_slab(): if memcg_cgroup_destroy_cache() is called in
	 * kmem_cache_shrink, not only we would be reinserting a dead cache
	 * into the queue, but doing so from inside the worker racing to
	 * destroy it.
	 *
	 * So if we aren't down to zero, we'll just schedule a worker and try
	 * again
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">memcg_params</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_cache_shrink</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cachep</span><span class="o">-&gt;</span><span class="n">memcg_params</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">"kdbg: destroy %p"</span><span class="p">,</span> <span class="n">cachep</span><span class="p">);</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kmem_cache_destroy_memcg_children</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">task_comm</span><span class="p">[</span><span class="n">TASK_COMM_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">task_comm</span><span class="p">[</span><span class="n">TASK_COMM_LEN</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">memcg_params</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">memcg_params</span><span class="o">-&gt;</span><span class="n">is_root_cache</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">memcg_limit_mutex</span><span class="p">.</span><span class="n">owner</span> <span class="o">==</span> <span class="n">current</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Get task command name. */</span>
		<span class="n">get_task_comm</span><span class="p">(</span><span class="n">task_comm</span><span class="p">,</span> <span class="n">memcg_limit_mutex</span><span class="p">.</span><span class="n">owner</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_EMERG</span> <span class="s">"kdbg: %s dead lock with cache %p"</span><span class="p">,</span> <span class="n">task_comm</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*
	 * If the cache is being destroyed, we trust that there is no one else
	 * requesting objects from it. Even if there are, the sanity checks in
	 * kmem_cache_destroy should caught this ill-case.
	 *
	 * Still, we don't want anyone else freeing memcg_caches under our
	 * noses, which can happen if a new memcg comes to life. As usual,
	 * we'll take the memcg_limit_mutex to protect ourselves against this.
	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg_limit_mutex</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">memcg_limited_groups_array_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">memcg_params</span><span class="o">-&gt;</span><span class="n">memcg_caches</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*
		 * We will now manually delete the caches, so to avoid races
		 * we need to cancel all pending destruction workers and
		 * proceed with destruction ourselves.
		 *
		 * kmem_cache_destroy() will call kmem_cache_shrink internally,
		 * and that could spawn the workers again: it is likely that
		 * the cache still have active pages until this very moment.
		 * This would lead us back to mem_cgroup_destroy_cache.
		 *
		 * But that will not execute at all if the "dead" flag is not
		 * set, so flip it down to guarantee we are in control.
		 */</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">memcg_params</span><span class="o">-&gt;</span><span class="n">dead</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">memcg_params</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">);</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">"kdbg: parent %p cache %p index %d is %s existing %p"</span><span class="p">,</span>
				<span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">is_root_cache</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">?</span><span class="s">"root"</span><span class="o">:</span><span class="s">"nonroot"</span><span class="p">,</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">memcg_params</span><span class="o">-&gt;</span><span class="n">memcg_caches</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg_limit_mutex</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>内核构建和安装：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># make -j8 bzImage
# installkernel 3.10.0-693.el7.x86_64 arch/x86/boot/bzImage System.map
</code></pre></div></div>
<p>如果使用 git 做了版本管理，make 会自动在版本号后面加上 “+”（例如 3.10.0-693.el7.x86_64+）。这时候需要使用如下命令编译去除：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># make LOCALVERSION= -j8 bzImage
</code></pre></div></div>

<p>重现死锁状态，得到日志：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Jul 19 12:13:14 c321v70 kernel: kdbg: destroy worker for ffff88021aa03a00 is called
Jul 19 12:13:14 c321v70 kernel: kdbg: destroy ffff88021aa03a00
Jul 19 12:13:14 c321v70 kernel: kdbg: recycle cache ffff88021aa03a00 which is nonroot
...
Jul 19 12:13:14 c321v70 kernel: kdbg: remove cache ffff88021aa03a00 from parent ffff8801f8b04b00 with index 775
Jul 19 12:13:14 c321v70 kernel: kdbg: recycled cache ffff88021aa03a00
Jul 19 12:13:14 c321v70 kernel: kdbg: parent ffff8801f8b04b00 cache ffff88021aa03a00 index 775 is root existing           (null)
Jul 19 12:13:14 c321v70 kernel: kdbg: recycle cache ffff88021aa03a00 which is root
Jul 19 12:13:14 c321v70 kernel: kdbg: kworker/u8:2 dead lock with cache ffff88021aa03a00
...
</code></pre></div></div>

<p>结论如下：
在某个时刻，释放 network namespace 的时候，调用 kmem_cache_destroy 删除关联的 root  kmem_cache。同时进入 kmem_cache_destroy_memcg_children 删除关联的 memory cgroup 对应的 child kmem_cache。在这个过程中，kmem_cache_destroy_memcg_children 对 memcg_limit_mutex 加锁，同时使用 cancel_work_sync 取消 child kmem_cache 的自我清理工作。</p>

<p>但是这个时候由于 cancel_work_sync 的工作机制，在 child kmem_cache 的自我清理工作已经开始的情况下，会等待工作完成才会返回。而清理工作完成后，会从 root kmem_cache 的 children 数组里将自己删除。</p>

<p>但是 kmem_cache_destroy_memcg_children  已经进入了循环并取得了被清理的指针 c，此时 c 是一个 dangling pointer。</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg_limit_mutex</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">memcg_limited_groups_array_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">memcg_params</span><span class="o">-&gt;</span><span class="n">memcg_caches</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">memcg_params</span><span class="o">-&gt;</span><span class="n">dead</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">memcg_params</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">);</span>
		<span class="cm">/*
		 * 问题就在这里，此时 s-&gt;memcg_params-&gt;memcg_caches[i] 已经为 NULL 了,
		 * 也就是说，不应该再对 c 进行清理操作。
		 */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">"kdbg: parent %p cache %p index %d is %s existing %p"</span><span class="p">,</span>
				<span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">is_root_cache</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">?</span><span class="s">"root"</span><span class="o">:</span><span class="s">"nonroot"</span><span class="p">,</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">memcg_params</span><span class="o">-&gt;</span><span class="n">memcg_caches</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg_limit_mutex</span><span class="p">);</span>
</code></pre></div></div>

<p>触发这个 BUG 需要达成如下条件：</p>
<ol>
  <li>child kmem_cache 进入自我清理状态</li>
  <li>root kmem_cache 加锁并进入循环状态，等待 child kmem_cache 清理完成。</li>
  <li>调用 kmem_cache_destroy 时，child kmem_cache 所处的内存又被申请出去使用，并且为 root。</li>
</ol>

      <div class="page-footer">
        <div class="page-share">
          <a href="https://twitter.com/intent/tweet?text=Centos 7 systemd 死锁问题分析&url=https://imkira.com/Linux-Systemd-Deadlock/" title="Share on Twitter" rel="nofollow" target="_blank">Twitter</a>
          <a href="https://facebook.com/sharer.php?u=https://imkira.com/Linux-Systemd-Deadlock/" title="Share on Facebook" rel="nofollow" target="_blank">Facebook</a>
          <a href="https://plus.google.com/share?url=https://imkira.com/Linux-Systemd-Deadlock/" title="Share on Google+" rel="nofollow" target="_blank">Google+</a>
        </div>
        <div class="page-tag">
          
            <a href="/tags#Linux" class="tag">&#35; Linux</a>
          
        </div>
      </div>
      <section class="comment-area">
  <div class="comment-wrapper">
    
  </div>
</section> <!-- End Comment Area -->

    </div> <!-- End Wrap Content -->
  </div> <!-- End Page Content -->
</article> <!-- End Article Page -->

</div>

  </div>
  
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', '', 'auto');
  ga('send', 'pageview');
</script> <!-- End Analytics -->

</body>
</html>
